<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      MyISAMを使っている時key_buffer_sizeは大きくし過ぎてもいけない &middot; 渋谷ではたらくインフラエンジニアのブログ
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="渋谷ではたらくインフラエンジニアのブログ" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">渋谷ではたらくインフラエンジニアのブログ</a>
          <small></small>
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">MyISAMを使っている時key_buffer_sizeは大きくし過ぎてもいけない</h1>
  <time datetime="2012-05-01T13:46:40-07:00" class="post-date">01 May 2012</time>
  <p>MyISAMのみを使っているMySQLサーバで、key_buffer_sizeのサイズは大きくても小さくてもダメですよ、という例。</p>

<p>その前にちょっと復習。MySQLの主なストレージエンジンといえばMyISAMとInnoDBだが、データやインデックスのキャッシュの仕組みには、</p>

<ul>
  <li>InnoDB : インデックス、データともMySQLがキャッシュ管理する(innodb_buffer_pool_sizeで設定)</li>
  <li>MyISAM : インデックスはMySQLがキャッシュ管理する(key_buffer_sizeで大きさを設定)。データはOSのキャッシュ機構におまかせ</li>
</ul>

<p>という違いがある。</p>

<p>ものすごく簡単に言えば、InnoDBの場合はなるべく大きな innodb_buffer_pool_size を設定してやれば、インデックスかデータかに関わらずメモリ上にキャッシュされて高速化が図れる可能性がある。一方MyISAMの場合、key_buffer_size を大きくしてもインデックスしかキャッシュされないので、OSがデータ部分をキャッシュするメモリ(つまりMySQLに割り当ててないメモリ)もある程度確保しておく必要がある。この辺りのことはMySQLのドキュメントには以下のように書かれている。</p>

<blockquote>
  <p>innodb_buffer_pool_size</p>
</blockquote>

<blockquote>
  <p>専用サーバの場合物理メモリの80%。</p>
</blockquote>

<blockquote>
  <p><a title="MySQL 5.1 リファレンスマニュアル 13.5.4. InnoDB 起動オプションとシステム変数" href="http://dev.mysql.com/doc/refman/5.1/ja/innodb-parameters.html" target="_blank">MySQL 5.1 リファレンスマニュアル 13.5.4. InnoDB 起動オプションとシステム変数</a></p>
</blockquote>

<blockquote>
  <p>key_buffer_size</p>
</blockquote>

<blockquote>
  <p>「一般的には、マシンのメモリ使用率 25 % の値であることが好ましい」一方で</p>
</blockquote>

<blockquote>
  <p>「Key_reads/Key_read_requests の比率は、0.01 より小さいことが望ましい」つまり</p>
</blockquote>

<blockquote>
  <p>99.9%がキャッシュされていることが望ましいということ。</p>
</blockquote>

<blockquote>
  <p><a title="MySQL 5.1 リファレンスマニュアル 4.2.3. システム変数" href="http://dev.mysql.com/doc/refman/5.1/ja/server-system-variables.html" target="_blank">MySQL 5.1 リファレンスマニュアル 4.2.3. システム変数</a></p>
</blockquote>

<p>とある参照用のスレーブ(MyISAMのみ使用)で、アクセス数とともにデータ量も増加して、インデックスがメモリに乗りきらず、Key_reads/Key_read_requests (以下key bufferヒット率という)が80%台まで落ちてしまっていた。</p>

<p>メモリを増設してkey_buffer_sizeを調子に乗ってでっかく取ってみたが、key bufferヒット率は99.9%になったものの、相変わらずディスクからの読み出しは多い。ここで、上に書いた仕組みに思い当たり、データ部分をキャッシュするOS用のメモリが不足しているのでは、と思って一旦key_buffer_sizeを少し減らしてみた。</p>

<ul>
  <li>インデックスのサイズ : 22GB</li>
  <li>従来 key_buffer_size : 4GB (OS物理メモリ12GB)</li>
  <li>増強後 key_buffer_size : 12GB (OS物理メモリ24GB)</li>
  <li>その後 key_buffer_size : 8GB (OS物理メモリ24GB)</li>
</ul>

<p>すると一目瞭然、以下のグラフの青枠部のようにディスクからの読み出しは半分以下に減った(赤線が設定を変更した時点)。</p>

<p><a href="http://b.l0g.jp/mysql/do-not-set-too-much-keybuffer/attachment/la-io/" rel="attachment wp-att-1018"><img src="http://b.l0g.jp/wp-content/uploads/2012/04/la-io.png" alt="" title="ロードアベレージとディスクIOの変化" width="522" height="343" class="alignnone size-full wp-image-1018" /></a></p>

<p>key_buffer_sizeを大きくしたからといってパフォーマンスが上がるというわけではないのである。上の例から分かるように、全インデックスがメモリに乗らなくても、よく使うインデックスがほぼメモリに乗っていれば問題ない。常に<strong>key bufferヒット率が最大になり、ディスク読み出しが最小になる key_buffer_size を探ることが必要</strong>ということだ。サイズはオンラインでも変更できる。ただし、コマンドを実行するとkey bufferの中身は一旦空になり、改めてキャッシュが構築されるため一時的にディスクIOが大量に発生するので注意(停止できるサーバならキャッシュウォームアップをした方がよい)。</p>

<p>[sql]</p>

<p>mysql&gt; set global key_buffer_size = バイトでのサイズ(1GBなら1073741824);</p>

<p>[/sql]</p>

<p>確認は show variables で。以下は4GBの例。</p>

<p>[sql]</p>

<p>mysql&gt; show variables like ‘key_buffer_size’;</p>

<p>+—————–+————+</p>

<table>
  <tbody>
    <tr>
      <td>Variable_name</td>
      <td>Value</td>
    </tr>
  </tbody>
</table>

<p>+—————–+————+</p>

<table>
  <tbody>
    <tr>
      <td>key_buffer_size</td>
      <td>4294967296</td>
    </tr>
  </tbody>
</table>

<p>+—————–+————+</p>

<p>1 row in set (0.00 sec)</p>

<p>[/sql]</p>

<p>そもそもインデックスがでか過ぎるのでシェイプアップすべきとか、テーブル分割を考えるべきといった別の解決方法も考えられるのだが、わかりやすいグラフが取れたのでひとつの例として。</p>

<hr />

<p><strong>海外の役立つブログ記事などを人力で翻訳して公開する<a href="https://yakst.com/ja">Yakst</a>というプロジェクトをやっています。よろしければそちらもどうぞ！</strong></p>

</article>


<aside class="related">
  <h3>Related posts</h3>
  <ul class="related-posts">
    
      <li>
        <a href="/aws/periodic-ebs-snapshot/">
          AWSのEBSボリュームのスナップショットを定期的に取る
          <small><time datetime="2015-10-19T06:33:30-07:00">19 Oct 2015</time></small>
        </a>
      </li>
    
      <li>
        <a href="/misc/my-twitter-bots/">
          Twitterボットを作るのがひそかな趣味
          <small><time datetime="2015-05-22T06:26:26-07:00">22 May 2015</time></small>
        </a>
      </li>
    
      <li>
        <a href="/uncategorized/sql-performance-explained-ja/">
          「SQLパフォーマンス詳解」という本を翻訳しました
          <small><time datetime="2015-04-07T01:45:15-07:00">07 Apr 2015</time></small>
        </a>
      </li>
    
  </ul>
</aside>


      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2016-04-01T11:15:44-07:00">2016</time>. All rights reserved.
        </small>
      </footer>
    </div>

    
  </body>
</html>
