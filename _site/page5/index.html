<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      渋谷ではたらくインフラエンジニアのブログ &middot; 
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="渋谷ではたらくインフラエンジニアのブログ" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">渋谷ではたらくインフラエンジニアのブログ</a>
          <small></small>
        </h3>
      </header>

      <main>
        <div class="posts">
  
  <article class="post">
    <h1 class="post-title">
      <a href="/linux/net-snmp-on-ipv6/">
        IPv6環境でnet-snmpを使う
      </a>
    </h1>

    <time datetime="2013-05-31T05:25:46-07:00" class="post-date">31 May 2013</time>

    <p>IPv6環境でSNMPで情報を引っ張ってきたいのだが、net-snmpをインストールしてsnmpdを起動したが、getできない。</p>

<p>監視サーバをnagios01、監視対象ホストをclient01とした時の例。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  
client01$ sudo yum install net-snmp net-snmp-utils
  
client01$ sudo /etc/init.d/snmpd start
  
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>  
nagios01$ snmpwalk -v 1 -c public client01 UCD-SNMP-MIB::laLoad.1
  
No log handling enabled - turning on stderr logging
  
getaddrinfo: client01 Name or service not known
  
snmpwalk: Unknown host (client01)
  
</code></pre>
</div>

<p>snmpwalkなどでIPv6のサーバへ問い合わせる場合は、ホスト名の前に「udp6」を明示的に指定する必要があるようだ。しかし、</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  
nagios01$ snmpwalk -v 1 -c public udp6:client01 UCD-SNMP-MIB::laLoad.1
  
Timeout: No Response from udp6:client01
  
</code></pre>
</div>

<p>タイムアウトになってしまう。ちなみに、<a href="http://www.net-snmp.org/docs/NEWS.html" target="_blank">net-snmpは5.0以降IPv6に対応している</a>ということなので、5.0以降がインストールされていれば、snmpwalkコマンドもIPv6を扱えるはず。</p>

<p>クライアント側を見てみる。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  
client01$ netstat -lanp
  
Active Internet connections (servers and established)
  
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
  
(中略)
  
udp 0 0 0.0.0.0:161 0.0.0.0:* 12403/snmpd
  
</code></pre>
</div>

<p>0.0.0.0:161ってことは、IPv4だけで、IPv6でリッスンしていない。</p>

<p>設定ファイルを見てみる。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  
client01$ cat /etc/snmp/snmpd.conf
  
(以下抜粋)
  
com2sec notConfigUser localhost public
  
com2sec notConfigUser nagios01 public
  
group notConfigGroup v1 nogConfigUser
  
access notConfigGroup "" any noauth exact systemview none none
  
syslocation Unknown (edit /etc/snmp/snmpd.conf)
  
syscontact Root &lt;root@localhost&gt; (configure /etc/snmp/snmp.local.conf)
  
view all included .1 80
  
dontLogTCPWrappersConnects yes
  
</code></pre>
</div>

<p>どうやら、デフォルトの設定では、IPv4しかリッスンしない設定らしい。以下のように、明示的にv6でも使えるように追記。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  
\# 以下の4行を追記(下の2行は実際の設定に応じて変更)
  
agentaddress udp:161
  
agentaddress udp6:161

com2sec6 notConfigUser localhost public
  
com2sec6 notConfigUser nagios01 public
  
</code></pre>
</div>

<p>snmpd を再起動すると、v6でもリッスンするようになった。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  
client01$ sudo /etc/init.d/snmpd restart
  
client01$ netstat -lanp
  
Active Internet connections (servers and established)
  
Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name
  
(中略)
  
udp 0 0 0.0.0.0:161 0.0.0.0:* 12442/snmpd
  
udp 0 0 :::161 :::* 12442/snmpd
  
</code></pre>
</div>

<p>これで値を取れるようになった。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  
nagios01$ snmpwalk -v 1 -c public udp6:client01 UCD-SNMP-MIB::laLoad.1
  
UCD-SNMP-MIB::laLoad.1 = STRING: 0.03
  
</code></pre>
</div>

<p><strong>まとめ</strong></p>

<p>IPv6環境でnet-snmpを使うときは</p>

<ul>
  <li>net-snmp 5.0以降を使う</li>
  <li>snmpd.confで、agentaddress udp6:161とcom2sec6を設定する</li>
  <li>snmpwalkなどで値を取る時はアドレスの前にudp6:をつける</li>
</ul>

<hr />

<p><strong>海外の役立つブログ記事などを人力で翻訳して公開する<a href="https://yakst.com/ja">Yakst</a>というプロジェクトをやっています。よろしければそちらもどうぞ！</strong></p>

  </article>
  
  <article class="post">
    <h1 class="post-title">
      <a href="/nagios/nagios-check-ifspeed-plugi/">
        NICのリンクスピードを監視するNagiosスクリプト
      </a>
    </h1>

    <time datetime="2013-02-17T08:30:00-08:00" class="post-date">17 Feb 2013</time>

    <p>Nagiosのプラグインには、NICのステータス(up/downとか)をチェックする check_ifstatus がある。しかし、ネゴシエーションなどの関係で、リンクアップはしているがリンクスピードが1Gbps full duplexであってほしいのに10Mbps halfとかになっているということはよくあること。</p>

<p>探してみた感じこれをチェックするためのNagiosプラグインはなさそうだったので、シェルスクリプト書いてみた。本当はcheck_ifstatus(perl)を拡張するのがいいのかもしれないが。</p>

<noscript>
  <pre><code class="language-shell shell">#!/bin/bash

#END STATUS
OK=0
WARNING=1
CRITICAL=2
UNKNOWN=3

# snmpwalk command
SNMPWALK=/usr/local/net-snmp/bin/snmpwalk

# default parameter
RET=${OK}
IP="127.0.0.1"
COMMUNITY="public"
INTERFACE="eth0"
SPEED=""
WARN_FLG="FALSE"
CRIT_FLG="FALSE"

# get parameter
while getopts H:C:i:w:c: OPT
do
    case $OPT in
        "H") IP="$OPTARG" ;;
        "C") COMMUNITY="$OPTARG" ;;
        "i") INTERFACE="$OPTARG" ;;
        "w") WARN_FLG="TRUE" ; WARN_TH="$OPTARG" ;;
        "c") CRIT_FLG="TRUE" ; CRIT_TH="$OPTARG" ;;
    esac
done

# check parameter
if [ ${WARN_FLG} = "FALSE" ] &amp;&amp; [ ${CRIT_FLG} = "FALSE" ] ; then
    echo "Parameter Error : -w or -c is required entry"
    exit ${WARNING}
fi

# get speed
INDEX=`${SNMPWALK} -t 10 -v 2c -c ${COMMUNITY} ${IP} ifDescr | grep ${INTERFACE} | sed 's/.*\.//' | sed 's/ .*//'`
SPEED_bps=`${SNMPWALK} -t 10 -v 2c -c casnmp ${IP} ifSpeed.${INDEX} | awk '{print $4}'`
SPEED=`expr ${SPEED_bps} / 1000000`

if [ -z ${SPEED} ] ; then
    echo "Can't get ${INTERFACE} speed"
    exit ${WARNING}
fi

# get result
if [ ${WARN_FLG} = "TRUE" ] &amp;&amp; [ ${CRIT_FLG} = "TRUE" ] ; then
    if [ ${SPEED} -lt ${CRIT_TH} ] ; then
        RET=${CRITICAL}
    fi
    if [ ${SPEED} -lt ${WARN_TH} ] &amp;&amp; [ ${OFFSET} -ge ${CRIT_TH} ] ; then
        RET=${WARNING}
    fi
fi
if [ ${WARN_FLG} = "TRUE" ] &amp;&amp; [ ${CRIT_FLG} = "FALSE" ] ; then
    if [ ${SPEED} -lt ${WARN_TH} ] ; then
        RET=${WARNING}
    fi
fi
if [ ${WARN_FLG} = "FALSE" ] &amp;&amp; [ ${CRIT_FLG} = "TRUE" ] ; then
    if [ ${SPEED} -lt ${CRIT_TH} ] ; then
        RET=${CRITICAL}
    fi
fi

# information
echo "${INTERFACE} speed is ${SPEED}Mbps now"

exit ${RET}
</code></pre>
</noscript>

<hr />

<p><strong>海外の役立つブログ記事などを人力で翻訳して公開する<a href="https://yakst.com/ja">Yakst</a>というプロジェクトをやっています。よろしければそちらもどうぞ！</strong></p>

  </article>
  
  <article class="post">
    <h1 class="post-title">
      <a href="/linux/meaning-for-linux-monolithic-kernel/">
        Linuxがモノリシックカーネルである理由
      </a>
    </h1>

    <time datetime="2013-01-10T00:53:06-08:00" class="post-date">10 Jan 2013</time>

    <p>Quoraの問答は本当に面白いものばかり。技術的でないのもかなり興味深いものが多いが、またLinuxについてのネタで分かりやすいのがあったので訳してみた。</p>

<p><strong><a href="http://www.quora.com/Linux/What-is-meant-by-Linux-has-a-monolithic-kernel">Linuxがモノリシックカーネルであるというのはどういう意味か？</a></strong></p>

<p><strong>モノリシックカーネル</strong></p>

<p>モノリシックカーネルは、プロセスやメモリの管理、例外の取扱い、入出力のやり取り、ファイルシステムなどほとんどの基本的なシステムサービスを実行する。層構造になっており、基礎的なプロセス管理からOSの他の部分(ライブラリ群や、層の最上位であるアプリケーション)とのインタフェースからなっている。基本的なサービスをカーネルスペースに含めることは、次のような大きな3つの欠点となる。</p>

<ul>
  <li>カーネルサイズが大きくなる</li>
  <li>拡張性に乏しい</li>
  <li>メンテナンス性が悪い</li>
</ul>

<p><strong>マイクロカーネル</strong></p>

<p>カーネルの機能を基本的なプロセス間通信と入出力制御のみに絞り、ユーザスペースの他のシステムサービスを普通のプロセス(「サーバ」と呼ばれる)としてしまうのがコンセプトである。あるサーバはメモリに関する管理を行い、別のサーバはプロセス管理、さらに他のサーバはドライバの管理…といった具合だ。サーバはカーネルスペースでは実行されないので、ユーザプロセスが特権モードに入ったり出たりするためにいわゆるコンテキストスイッチが発生してしまう。この方式では、マイクロカーネルはもはやシステムサービスの塊ではなく、プロセス間通信とプロセスとその下のハードウェアとの通信を制御するための、単にいくつかの基本的な抽象化とプリミティブを提供するだけである。通信は直接行われないので、独立した通信と拡張性をもたらす、メッセージングの仕組みが使われる。</p>

<p>ここでLinuxカーネルの話に入ろう。Linuxカーネルは、モノリシックカーネルである。しかし、Linuxの美しいところは、どちらとしてもコンパイルできることである！</p>

<p>モノリシックカーネル</p>

<ul>
  <li>1つのバイナリファイル</li>
  <li>全ドライバがカーネル自体に含まれる</li>
</ul>

<p>モジュラーカーネル</p>

<ul>
  <li>複数のカーネルのファイル</li>
  <li>ドライバはmodprobeコマンドなどでカーネルにロードしたりアンロード可能。lsmodやmodprobeのmanページを参照</li>
  <li>ほとんど全てのドライバはカーネルに対してビルドされてリンクされる</li>
</ul>

<p>以下のカーネルコンフィグオプションの設定でモジュラーカーネルをビルドすることができる。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  
Enable loadable module support (CONFIG_MODULES) [Y/n/?]
  
</code></pre>
</div>

<p>このオプションにYと答えるとモジュラーカーネルとなり、各機能やドライバそれぞれに関して3つの選択肢が現われる。</p>

<table class="article">
  <tr>
    <td>
      m
    </td>
    
    <td>
      ドライバをモジュールとしてコンパイルできる
    </td>
  </tr>
  
  <tr>
    <td>
      y
    </td>
    
    <td>
      カーネル自身に組み込む
    </td>
  </tr>
  
  <tr>
    <td>
      n
    </td>
    
    <td>
      機能・ドライバを含まない
    </td>
  </tr>
</table>

<p>(CONFIG_MODULES)オプションを n に設定した場合モノリシックカーネルとなり、各機能やドライバそれぞれに2つの選択肢がある。</p>

<table class="article">
  <tr>
    <td>
      y
    </td>
    
    <td>
      機能・ドライバを含む
    </td>
  </tr>
  
  <tr>
    <td>
      n
    </td>
    
    <td>
      機能・ドライバを含まない
    </td>
  </tr>
</table>

<p> </p>

<hr />

<p><strong>海外の役立つブログ記事などを人力で翻訳して公開する<a href="https://yakst.com/ja">Yakst</a>というプロジェクトをやっています。よろしければそちらもどうぞ！</strong></p>

  </article>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page6">Older</a>
  
  
    <a class="pagination-item newer" href="/page4">Newer</a>
  
</div>

      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2016-04-01T11:57:39-07:00">2016</time>. All rights reserved.
        </small>
      </footer>
    </div>

    
  </body>
</html>
